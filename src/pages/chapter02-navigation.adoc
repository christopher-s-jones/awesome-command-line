== Navigation Commands

=== Getting Around in Your File System

In _Chapter 1. Foundations_, we set up our terminal application environment, familiarized ourselves with command line concepts and syntax, and now know how to write and edit commands by controlling our cursor.  In this chapter, we begin to put these skills to work by using the command line to navigate and view the files and folders that we have on our computers.  We are all very familiar with opening a Finder window on macOS, or an Explorer window on Windows or Linux, and viewing our folders and files.  These are the bread-and-butter tools of the graphical user interface.  In the command line world, we have commensurate ways to view our folders and files, which we will explore in the following sections.  Taken as a whole, the folders and files on your computer's storage drives are organized in a _file system_, which is a means of associating folder and file names with physical hardware locations.  For modern _solid state drives_ (_SSDs_) and USB sticks, file and folder data are stored on flash-based memory chips, and for older magnetic _hard drives_ (_HDDs_), they are stored on spinning magnetic plates.  On Windows computers, each physical drive is usually represented by a drive letter like `+C:+`.  A USB drive mounted under Windows may show up as the `+D:+` drive.  Therefore, on Windows, there are multiple top-level drive names, and each have their own file system for organizing folders and files.

On UNIX-like operating systems like macOS and Linux, there is a single top-level folder, and all physical drives are represented as a subfolder in this type of file system.  The top-level folder is called the _root directory_, and is denoted by a single `+/+` (forward slash) character.  

NOTE: In computing terminology, a _directory_ is synonymous with a _folder_, and it is common to use the word "directory" when using the command line.

When talking about this root directory, it is usually referred to as _slash_ (a shorthand for forward slash).  _Figure 17_ shows the root directory and the immediate sub-directories on a typical macOS installation.

image::chapter-02-macOS-top-level-folders.png[title="The root directory (called slash) and its immediate sub-directories shown on macOS.", pdfwidth=100%]

You can see that everything is organized under a single directory, and we'll be discussing this directory hierarchy in the coming sections.  _Figure 17_ depicts what first-level sub-directories are shown in the graphical user interface, but in reality there are a number of other sub-directories at this level that can be shown in the command line interface, and we will explore that shortly.  But first, let's have a look at our first command that we briefly introduced in previous sections called `+pwd+`.  This command can help us illustrate a location in the file system hierarchy, so let's have a look!

=== The pwd Command--Print the Working Directory

As we've seen in _Chapter 1. Foundations_, opening up a terminal application presents us with a command line prompt in a surprisingly empty window.  Let's put that window to use and execute our first command, `+pwd+`, which is an acronym that stands for "print working directory".  In the command line world, the term "print" here means "show the results in the terminal window", as opposed to physically printing the results to paper as was the case on historical computers.  Open your terminal and type the `+pwd+` command, followed by the kbd:[Return] key.  _Example 6_ shows the `+pwd+` command on macOS and the result printed on the second line of the terminal.

.Issuing the `+pwd+` command on macOS.
[source, console, caption="Example {counter:listing-counter}: "]
----
chris@ophir ~ % pwd
/Users/chris <1>
----
<1> The result of issuing the `+pwd+` command is shown on the second line of the terminal.

Awesome!  While we've seen this before, this is our first successful command!  You can see that the result that printed to the terminal window is, in my case, `+/Users/chris+`, which should look familiar now that we have a better understanding of the UNIX-like file system hierarchy.  Your command should show `+/Users/<your-username>+` if you are on macOS.  This command is telling you that the _working directory_, meaning the current directory location of your command line terminal is your home directory, located at `/Users/<your-username>` in the file system.

And if you are on Linux, you will see a similar result.  _Example 7_ shows the same command on Linux.

.Issuing the `+pwd+` command on Linux.
[source, console, caption="Example {counter:listing-counter}: "]
----
chris@nuthatch:~$ pwd
/home/chris 
----

Likewise, if you are on Windows with Ubuntu Linux integrated with WSL, you will also see a simlar result.  _Example 8_ shows the same command on Windows.

.Issuing the `+pwd+` command on Windows using Windows Subsytem for Linux.
[source, console, caption="Example {counter:listing-counter}: "]
----
chris@DESKTOP-L7H0RFS:~$ pwd
/home/chris <1>
----
<1> Note that the home directory under WSL Linux is different than the Windows home directory of `+C:\\Users\chris+`, explained later.

We can see some differences across macOS, Linux, and Windows in the results of the `+pwd+` command, but they all show that the current working directory is the user's home directory.  We'll explain the difference between the Windows user home directory and the WSL Linux user's home directly shortly, but suffice it to say that the `+pwd+` command shows that we all begin our journey on the command line in our account's home folder.

=== Understanding File and Directory Paths

We've been discussing the results of the `+pwd+` command, and this is a good time to define what those characters really represent, which is a _directory path_.  A directory path is a concise way to represent the path through the hierarchy of the file system tree to a given directory with just text characters.  And likewise, a _file path_ is a concise representation of a path through the file system tree to a given file.  Directory and file paths use the `+/+` (forward slash) character to separate folder and file names in the path.  This, unsurprisingly, is called the _path separator_.  _Figure 18_ depicts the directory path represented by `+/Users/chris+`.  

image::chapter-02-macOS-directory-path.png[title="The path from the root directory (slash) to the home directory of the user chris on macOS, shown as a dashed line.", pdfwidth=100%]

Now more specifically, the directory path of `+/Users/chris+` is considered an _absolute path_.  It is absolute because it begins with the root directory `+/+` (slash).  On the command line, it can be helpful to refer to files and folders as absolute paths, but it can also be overly verbose, and there is a great shortcut we can use, called a _relative path_.  A relative path is the path to a file or directory in the filesystem, but originating from the current directory.  But how do we represent what the current directory is, similar to what the `+pwd+` command produces?  Oh, we have the magic!  On UNIX-like systems, the current directory is represented as a single `+.+` (period) character.  Wait, what? Just a period?  Yes, surprisingly, just a period!  This is the most succinct way to say "you are here"!  To provide an example, let's say that I have downloaded a file from the Internet called `+funny-cats.jpg+`, and I saved it to my `+Downloads+` folder in my home directory.  On the command line I can refer to this file as a relative path from my current working directory of `+/Users/chris+` with the following syntax: `./Downloads/funny-cats.jpg`.  As we'll see later in _Chapter 3. File Commands_, we can work with files by referring to them with this relative path format.  The `+.+` (period) character tells the shell interpreter to start from my current directory and traverse into my `+Downloads+` directory to precisely locate my cat photo. The same file can of course be referenced as an absolute path with `+/Users/chris/Downloads/funny-cats.jpg+`, but we save some keystrokes by using the relative path format, and when you happen to be located deep in nested folders, it can save a lot of typing.

NOTE: The shell also interprets `+Downloads/funny-cats.jpg+` as a relative path with no `+./+` characters at the beginning.  Using the `+./+` (dot slash) syntax is just slightly more explicit.

One last very helpful shorthand symbol for creating relative paths is the `+~+` (tilda) character.  This character indicates your home directory, so if I am logged in as `+chris+`, `+~+` is equivalent to `+/Users/chris+` on macOS, or `+/home/chris+` on Linux and Windows WSL.  If you want to refer to another user's home directory, you can use `+~venus+` or `+~leo+`.

So far we have discussed relative paths from the current directory that are downstream in subdirectories.  But what if we want to refer to a file in a directory that is not below our current directory, but up and in another path altogether? Yes, we have the power! By using the syntax of a parent directory, which is represented by `+..+` (double periods), we can construct a relative path into any other directory in the file system.  For example, let's say my teammate, Venus, also has an account on my machine, and has downloaded a really fun cat photo into her `+Pictures+` directory in her home directory.  With her permission, I can refer to this file with the following relative path: `+../venus/Pictures/supercat.jpg+`.  Since her home directory is `+/Users/venus+`, I can point to my current parent directory of `+/Users+` using the `+..+` syntax, and then into Venus' `+Pictures+` directory from there.  The `+..+` parent directory syntax is very powerful, because you can chain them together. For instance, from the current directory of `+/Users/chris+`, I can refer up two parents with `+../../+`, which is the equivalent of the `+/+` root directory (up one to `+Users+`, and up another to `+/+`).

_Table 2_ summarizes the common file and directory path components we've discussed in this section.

.Examples of absolute and relative directory and file paths.
[%header,cols="^60m,^~m"]
|===
|Absolute Paths 
| Relative Paths

|/home/leo
|../leo

|/Users/Pictures/venus
|./Pictures/supercat.jpg

|/Users/chris/Downloads/funny-cats.jpg
|Downloads/funny-cats.jpg

| /Users/venus
| ~venus
|===

We'll see more of the relative and absolute paths as we get familiar with more commands.  But for now, let's take a look at how we learn to use any command in the next section on the `+man+` command!

=== The man Command--Accessing the Manual for Any Command

We now have a solid understanding of how to reference file system locations using both absolute and relative paths.  Let's turn now to navigating the world of commands, and how to be guided through the details of each command.  The creators of these commands really want you to succeed in using them! To facilitate your success, they communicate all of the details about a command in what is called a _manual page_, which contains everything you need to know about a command. When commands are installed on your machine, a manual page also gets installed that provides:

- A short synopsis of how to use the command and the purpose of the command.
- A longer description of the command and how to use it.
- An explanation of each short and long option available for the command.
- Examples of how to use the command.
- Historical information about the authors and other details.

==== Viewing a manual page

In order to access these manual pages, we will introduce another command, called `+man+`.  Yes, it is shorthand for "manual page"!  So when we need to know what a command does, what the options and other arguments are for the command, we use the following syntax: `+man <command-name>+`, where `+<command-name>+` is the name of the command that we need guidance on.
Let's begin with an example using the `+pwd+` command, since it is very simple.  Go ahead and type `+man pwd+` and you should see output in your terminal that is similar to _Figure 19_.


image::chapter-02-linux-manual-page-example.png[title="Issuing the `+man pwd+` command on Linux.", pdfwidth=100%]


// <1> The quick definition of a command shows at the top of the manual.
// <2> The synopsis shows the syntax--bracketed arguments are optional, non-bracketed arguments are required.
// <3> The last line in your terminal shows the paging help and instructions

Let's discuss the four items highlighted in _Figure 19_.

[.calloutnumber]##❶## Name:: You will first see that there is name a quick definition of the command toward the top of the manual page. 

[.calloutnumber]##➋## Synopsis:: The synopsis shows the syntax rules for using the command.  Square brackets around a command argument means that they are optional, and arguments without square brackets are required.  In the case of the `+pwd+` command, there are no required arguments.  The word `+OPTION+` in this context means any of the short or long options are placed in this position when using the command.

[.calloutnumber]##❸## Description:: The description gives all of the details about the command, and will define each of the short and long options that are available.

[.calloutnumber]##❹## Paging Information:: Notice that while the output is printed directly in your terminal window based on the size of your window, only a portion of the manual page is shown, discussed below.

Modern versions of the `+man+` command use a paging mechanism that let's you scroll through the rest of the details, but it is different than scrolling with your mouse.  Since manual pages can be very long, navigating them is an art in and of itself, and we will highlight some of the most useful ways to find the information that you need in the following sections.

NOTE: If you are on macOS, the output that you see will be slightly different because the origins of many macOS commands are slightly different than Linux commands.{empty}footnote:[The origins of macOS stem from the NeXTSTEP operating system (acquired by Apple) and the FreeBSD operating system.  The latter is a free and open source version of the Berkeley Software Distribution (BSD) Unix, developed at the University of California Berkeley campus. See https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/BSD/BSD.html]

==== Moving around in a manual page

Look at the last line of the output in _Figure 9_, which states `+Manual page pwd(1) line 1 (press h for help or q to quit)+`.  This line with the dark background is part of the paging mechanism, and is showing you what line number you are viewing in the manual page.  It also lets you know that there is an internal help system to the paging mechanism (by typing an `+h+` character), and that you can exit the manual page viewer by typing the `+q+` character (shorthand for quit).

Thank you manual page creators!  Let's just summarize a few of the most useful ways to navigate a manual page that are listed in the help section, because there are a lot of key combinations shortcuts listed in the help.

Spacebar:: The most direct way to see more of the manual page information is to press the kbd:[Spacebar] key, which scrolls through the paged content.  This is a quick way to scan through the manual, and it moves you forward one window's worth of the page at a time.  

Arrow keys:: Likewise, the kbd:[&nbsp;▴&nbsp;] (up arrow) and the kbd:[&nbsp;▾&nbsp;] (down arrow) keys let you scroll up and down through the window one line at a time to find just what you're looking for.  

Quit Viewing:: When you are finished reading the manual page, you can use the kbd:[q] key to quit the viewer.

Now, there are times when a manual page is very long, and you scroll down through the page to scan for what you are looking for. If you have scrolled past the section you are interested in, how do you scroll back up?  The line-by-line kbd:[&nbsp;▴&nbsp;] (up arrow) is just too slow--we need to scroll page by page, backward through the manual.  With letter keys, we have the power!

Letter keys:: 
* kbd:[f]{emdash}Scroll forward one window page.
* kbd:[b]{emdash}Scroll backward one window page.
* kbd:[j]{emdash}Scroll forward one line.
* kbd:[k]{emdash}Scroll backward one line.

So the kbd:[b] key lets us scroll by page back up!  These little gems are right at your fingertips and get you exactly where you want to go in the manual.  _Figure 19_ shows the useful keys we've highlighted.

image::chapter-02-man-command-keyboard-shortcuts.svg[title="Useful keyboard shortcuts when viewing a manual page, including the spacebar (forward page-by-page); down and up arrows (forward and backward line-by-line); f and b keys (forward and backward page-by-page); j&nbsp;and&nbsp;k (forward and backward line-by-line), and q (quit the viewer).", pdfwidth=100%]

Great! You now have the tools to navigate any manual page for any command.  As you work with commands repeatedly, you will remember many of the short and long options that are available because you use them regularly.  Repetition is your friend! 

==== Searching within a manual page

There are some command options that you will use infrequently, so to refresh your memory on how to use them, you can search within the manual page for the exact option you want to use.  To do so, use the kbd:[/] (slash) key followed by what you want to find.

Let's use the `+man pwd+` command output as an example again.  When you type that command, you will see there is a `+-P+` short option for the `+pwd+` command. Let's search for it.  Typing the kbd:[/] slash key on your keyboard while you are viewing the manual page tells the paging mechanism that you want to search.  _Example 10_ shows how to search for the `+-P+` option.

.While viewing a manual page, a single `+/+` (slash) key invokes a search, followed by what you want to find.
[source, console, caption="Example {counter:listing-counter}: "]
----
/-P
----

Give it a try!  Your cursor will show at the very bottom-left corner of your window.  Anything that you type after the kbd:[/] (slash) character is considered your _search pattern_.  When you press the kbd:[Return] key,{emdash}Whoosh!{emdash}The manual page scrolls directly to the first instance of the `+-P+` characters.  This shortcut can save a lot of time when you know what you are looking for.  

Another example would be to search for the EXAMPLES section of the manual page by typing `+/EXAMPLES+` and the kbd:[Return] key. If this section exists for the command it will jump right to it, or it will tell you "Pattern not found".

TIP: The navigation keys that are useful when viewing a manual page are derived from the functionality of the `+less+` command, which we explore in _Chapter 6. Utilities_.  So these keyboard shortcuts will come in handy elsewhere.

==== Occassional mistakes

Okay, we now have a good sense of how to read the manual pages for our commands, and how to navigate the manual page viewer.  These skills become second-nature as you practice using commands.  It is very common, however, to mistype a command on the command line, and get a very unexpected result!  Let's purposefully insert a typo into our command and type `+mane pwd+`.  Try it yourself!  _Example 11_ shows the output from the shell interpreter.

.Demonstrating an incorrect command by issuing `+mane pwd+` on Linux.
[source, console, caption="Example {counter:listing-counter}: "]
----
chris@nuthatch:~$ mane pwd <1>
Command 'mane' not found, did you mean:
  command 'mace' from snap mace (0.2.0)
  command 'mame' from snap mame (mame0270)
  command 'mame' from deb mame (0.261+dfsg.1-1)
  command 'make' from deb make (4.3-4.1build1)
  command 'make' from deb make-guile (4.3-4.1build1)
  command 'mne' from deb python3-mne (1.3.0+dfsg-1)
  command 'man' from deb man-db (2.12.0-1) <2>
See 'snap info <snapname>' for additional versions.
----
<1> Mistakenly typing `+mane+` instead of `+man+`
<2> Some helpful information points you to similar command names

Hah! It's easy to make mistakes--they happen all of the time.  The shell interpreter prints out a response that lets you know that it didn't recognize the command that you typed, and provides you with a number of possible alternatives that are similar to what you typed.  Thanks for tip!  Now you can correct your mistake by re-typing the command. That said, sometimes commands can be very long, and re-typing them can be tedious. In the next section where we introduce the `+clear+` command, we'll also revisit the wonderful shortcut where you can summon a command back like magic!

=== The clear Command--Keeping It Tidy

In the previous section, we described how to view and navigate a manual page for any command, and when you pressed the `+q+` key on the keyboard, the contents of the manual page dissapeared.  That is because the viewer has built in functionality to clear the screen, which helps you get directly back to your work.  However, the output from most of our commands generally stays in the terminal window, and scrolls up and out of view as we type.  This is known as your _session history_.  Our command prompt always shows back up after the output of the previous command, ready for our next command.  But as you can see from our mistakenly-typed `+mane+` command, the output may be useful in the moment, but it would also be nice to just clear the screen and start anew.  Yes, it's so easy!  As you probably guessed, the `+clear+` command does just that--it clears the contents of the terminal window, resets the prompt to the top of the window, and sets us up for our unobstructed next command.  Keep it tidy!

Feel free to type `+clear+` to clear your terminal window at any time that you feel that things are getting cluttered.  When you do so, the command usually clears the visible part of your window. There is also a concept of a _scrollback buffer_, which is the in-memory record of your terminal session from previously typed commands and their output.  To scroll back and view your terminal session history, you can use your mouse, trackpad, or mouse wheel.    Most terminal applications let you configure the number of lines of scrollback that it maintains in memory so you can scroll back and review or copy any output.  

Use the `+man clear+` command to read the manual page for the `+clear+` command.  There are slight differences between the macOS and Linux versions of the command, but they both clear the active window.

TIP: On macOS, you can use the kbd:[Command] + kbd:[ K ] key combination to clear the entire scrollback buffer.  In Linux and Windows Subsystem for Linux, the `+clear+` command clears the full buffer, unless you include the `+-x+` option.

==== Revisiting the command history

Now that we are able to clear the slate and start with a fresh command prompt at the top of our terminal window, we can re-type our command after making a minor mistake from the previous section  when we typed `+mane pwd+`.  But let's assume we issued a very long command that would take a while to type again.  Our _command history_ is our friend!  As we briefly mentioned in _Chapter 1. Foundations_, the shell interpreter keeps a history of all of the commands that we run, up to a configurable number of commands.  So getting back to them is super easy.  

At the command prompt, just press the kbd:[&nbsp;▴&nbsp;] (up arrow) key once, and your previous command will show up on the command line.  It's like magic!  This is one of the most useful shortcuts ever made and is worth repeating here.  While using the command line is all about typing, using the modern command line is all about typing the minimum amount to get the job done quickly.

You can now move your cursor left and right to edit you last command, and the kbd:[Return] key to re-issue it.  So helpful!  I'm sure you're wondering about even earlier commands, yes?  They are also available!  As we've mentioned earlier, pressing the kbd:[&nbsp;▴&nbsp;] (up arrow) multiple times will walk you through your command history one command at a time, so you can always get back to your most useful commands.  If you pass by a command while arrowing up, you can use the kbd:[&nbsp;▾&nbsp;] (down arrow) key to walk forward to your more recent commands.  Such a gem!

Now that we are familiar with issuing commands, viewing our current directory, reading the manual pages for commands, and clearing our terminal window, we are now empowered to dive into the two commands that are everyday staples on the command line--the `+cd+` and the `+ls+` commands.  These two commands are tiny but powerful!  Let's learn to travel around the file system and display it all with ease!

=== The cd Command--Changing Directories

, and they not only illustrate the slight differences in locations, but we can also see that on Windows, the result of `/home/chris+` is different than the Windows user home directory of `+C:\\Users\chris+`.  The WSL Linux user account is different from the Windows user account, but you do have access to all of your files.  As we mentioned earlier, UNIX-like operating systems have a root directory with everything underneath it, whereas Windows has multiple top-level drives (`+C:+`,`+D:+`, etc.)  To integrate the Windows filesystem into Linux, the `+C:+` drive is mapped to `+/mnt/c+` under Linux, which places it into the single file system hierarchy.  But why would it be called `+/mnt+`?  In 

Lorem ipsum odor amet, consectetuer adipiscing elit. At penatibus habitant malesuada tortor ultrices erat. Justo ad fringilla lacus consequat, blandit ut montes. Phasellus turpis euismod fusce curabitur suspendisse taciti. Molestie nunc enim sociosqu ad nostra ex etiam vel parturient. Porta molestie tristique blandit accumsan, pretium egestas fusce. Lobortis eget tristique interdum, nullam primis porta platea.

=== Understanding Tab Completion

Lorem ipsum odor amet, consectetuer adipiscing elit. At penatibus habitant malesuada tortor ultrices erat. Justo ad fringilla lacus consequat, blandit ut montes. Phasellus turpis euismod fusce curabitur suspendisse taciti. Molestie nunc enim sociosqu ad nostra ex etiam vel parturient. Porta molestie tristique blandit accumsan, pretium egestas fusce. Lobortis eget tristique interdum, nullam primis porta platea.

=== The ls Command--Listing Files and Folders

Lorem ipsum odor amet, consectetuer adipiscing elit. At penatibus habitant malesuada tortor ultrices erat. Justo ad fringilla lacus consequat, blandit ut montes. Phasellus turpis euismod fusce curabitur suspendisse taciti. Molestie nunc enim sociosqu ad nostra ex etiam vel parturient. Porta molestie tristique blandit accumsan, pretium egestas fusce. Lobortis eget tristique interdum, nullam primis porta platea.

image::chapter-02-figure-home-directory-window.png[title="The home folder on Linux showing the sub-folders."]

.Using the `ls` command to produce a long listing (`-l`) with human readable sizes (`-h`)
[source, console, caption="Example {counter:listing-counter}: "]
----
chris@nuthatch:~$ ls -lh
total 36K <1>
drwxr-xr-x 2 chris chris 4.0K Jan 10 10:01 Desktop
drwxr-xr-x 2 chris chris 4.0K Jan 10 10:01 Documents
drwxr-xr-x 2 chris chris 4.0K Jan 10 10:01 Downloads
drwxr-xr-x 2 chris chris 4.0K Jan 10 10:01 Music
drwxr-xr-x 3 chris chris 4.0K Jan 10 10:11 Pictures  <2>
drwxr-xr-x 2 chris chris 4.0K Jan 10 10:01 Public
drwx------ 3 chris chris 4.0K Jan 10 10:01 snap
drwxr-xr-x 2 chris chris 4.0K Jan 10 10:01 Templates
drwxr-xr-x 2 chris chris 4.0K Jan 10 10:01 Videos
----
<1> A technical total of the number of disk blocks used in the current folder
<2> The listing of items in _chris'_ home folder with accompanying details


image::chapter-02-figure-long-listing.svg[title="Understanding the columns of the long listing output.",pdfwidth=100%]

<<<
=== Command Line Navigation is Awesome!

Lorem ipsum odor amet, consectetuer adipiscing elit. At penatibus habitant malesuada tortor ultrices erat. Justo ad fringilla lacus consequat, blandit ut montes. Phasellus turpis euismod fusce curabitur suspendisse taciti. Molestie nunc enim sociosqu ad nostra ex etiam vel parturient. Porta molestie tristique blandit accumsan, pretium egestas fusce. Lobortis eget tristique interdum, nullam primis porta platea.

